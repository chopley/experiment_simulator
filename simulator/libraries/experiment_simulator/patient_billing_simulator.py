import datetime
import random

import numpy as np
import pandas as pd


# Function to check if list is formed by consecutive integers
def check_consecutive(array_vals):
    # compute minimum and maximum element in a list
    minimum = min(array_vals)
    maximum = max(array_vals)
    # in order for a list to contain consecutive integers, the difference
    # between maximum and element element in it should be exactly n-1
    if maximum - minimum != len(array_vals) - 1:
        return False
    # create an empty set (we can also use a visited list)
    visited = set()
    # traverse the list and checks if each element appears only once
    for i in array_vals:
        # if element is seen before, return false
        if i in visited:
            return False
        # mark element as seen
        visited.add(i)
    # we reach here when all elements in list are distinct
    return True


class BillingData:
    """
    It is useful to be able to simulate patient payment behaviour under different circumstances and assumptions
    This class generates toy data that resembles Cedar data. These data can be used for testing how changes in assumptions
    affect the output data. The data can also be used for interviews and similar.

    Testing:
    python3 -m unittest tests.test_patient_billing_simulator -v

    eng.write_to_csv()
    """

    def __init__(self):
        self.Customers = pd.DataFrame()
        self.InvoiceLineItems = pd.DataFrame()
        self.InvoiceLineItemsEob = pd.DataFrame()
        self.InvoiceProviderAdjustments = pd.DataFrame()
        self.Payments = pd.DataFrame()
        self.Remaining = pd.DataFrame()

    def setup_base_settings(
        self,
        number_of_dates_to_be_generated_per_patient,
        dunning_cycle_length,
        possible_invoice_dates,
        customer_ids,
        dob_range,
        cpt_codes,
        distributions,
    ):
        """
        number_of_dates_to_be_generated_per_patient - number of date events that will be generated per patient- for example, if you expect that
            the patient will visit the provider, and then pay his bill on a subsequent date- you would only need two events
        dunning_cycle_length - length of the billing cycle - events will only happen within this time window
        possible_invoice_dates - dates that will be used to randomly sample the visit date from e.g.
            possible_visit_dates = pd.date_range(
                start="2018-09-09", end="2020-02-02"
            ).sort_values()
        customerIds - list of customer IDs that will be used to assign the visits to - should be monotonically increasing
        dob_range - dictionary with startDate and endDate e.g. dob_range = {"start_dob": "1972-04-24", "end_dob": "2002-04-27"}
        cpt_codes - codes used to define the different procedures - used for random allocation to different procedures with equal probability
        distributions - dictionary containing the distributions used in the simulations e.g.
            "insurance_status": ["insured", "not_insured"],
            "insurance_distribution": [0.7, 0.3],
            "copay_amounts": [0, 25, 50],
            "copay_distribution": [0.1, 0.7, 0.2],
            "eob_discount_percentages": [0, 25, 50, 75, 100],
            "eob_discount_distribution": [0.2, 0.2, 0.2, 0.2, 0.2],
            "eob_payment_percentages": [0, 25, 50, 75, 100],
            "eob_payment_distribution": [0.1, 0.1, 0.1, 0.1, 0.6],
            "provider_adjustment_percentages": [0, 25, 50, 75, 100],
            "provider_adjustment_distribution": [0.5, 0.1, 0.2, 0.1, 0.1],
            "payment_percentages_arm_1": [0, 20, 40, 60, 80, 100],
            "payment_distribution_arm_1": [0.6, 0.05, 0.05, 0.05, 0.05, 0.2],
            "payment_percentages_arm_2": [0, 20, 40, 60, 80, 100],
            "payment_distribution_arm_2": [0.3, 0.05, 0.05, 0.05, 0.05, 0.5]
        """
        self.number_of_dates_to_be_generated_per_patient = (
            number_of_dates_to_be_generated_per_patient
        )
        self.dunning_cycle_length = dunning_cycle_length
        self.dates = possible_invoice_dates
        self.customerIds = customer_ids
        self.consecutive = check_consecutive(self.customerIds)
        if self.consecutive == False:
            print("Error setting up the object- customerIds aren't consecutive")
            print(self.customerIds)
        self.dobs = pd.date_range(
            start=dob_range["start_dob"],
            end=dob_range["end_dob"],
            periods=len(self.customerIds),
        ).date  # range of valid dates of birth for the patients
        self.CPTCodes = cpt_codes  # CPT codes to choose from
        self.invoices = [
            10000
        ]  # first invoice id- other invoices are monotonically increasing i.e. generated by adding one to the previous invoice.

        # dictionary used to define the assumptions used in generating the data set
        self.distributions = distributions
        return True

    def billing_choose_dates(self):
        """
        This method returns a set of randomly chosen dates from a list of dates. This makes it possible to simulate a patient visit to
        a provider, as well as the follow ups.
        Returns the a list of dates that will be used for the billing of this particular patient
        """
        number_of_dates_to_be_generated_per_patient = (
            self.number_of_dates_to_be_generated_per_patient
        )
        dunning_cycle_length = self.dunning_cycle_length
        dates = self.dates
        first_date = random.choice(
            dates
        )  # randomly choose a start date from the list of possible start dates
        last_possible_date = first_date + datetime.timedelta(
            days=dunning_cycle_length
        )  # calculate the last date possible based on Dunnin Cycle
        time_between_dates = last_possible_date - first_date
        subsequent_events = random.sample(
            list(np.arange(0, time_between_dates.days)),
            number_of_dates_to_be_generated_per_patient,
        )
        subsequent_events.sort()
        dates = [
            first_date + datetime.timedelta(days=np.int(subsequent_event))
            for subsequent_event in subsequent_events
        ]
        event_list = pd.DataFrame(dates)
        return event_list

    def generate_customer_info(self):
        """
        Populate a dataframe for Customer metadata including insurance information, patient date of birth, etc.
        """
        consecutive = check_consecutive(self.customerIds)
        print("consecutive" + str(consecutive))
        if consecutive:
            for customer_id in self.customerIds:
                # next we need to 1) decide if the customer has insurance, and if yes, generate the EOB that gets sent to the customer
                insured = np.random.choice(
                    self.distributions["insurance_status"],
                    1,
                    p=self.distributions["insurance_distribution"],
                )[0]
                dob = self.dobs[customer_id - 1]
                customer = pd.DataFrame(
                    {
                        "customer_id": [customer_id],
                        "dob": str(dob),
                        "insurance": insured,
                        "experiment_id": random.randint(1, 2),
                    }
                )
                self.Customers = self.Customers.append(customer)
        else:
            print("Error generating customer info: customerIds aren't consecutive")
        return True

    def generate_new_visit(self):
        """
        This method is called each time you need to simulate a new visit. It will randomly choose a set of dates for you,
        and then set up a visit, with subsequent EOBs, provider adjustemnts and payments.
        """
        if self.consecutive:
            customer_id = np.random.choice(
                self.customerIds, 1
            )  # choose a customer at random
            insured = self.Customers[self.Customers["customer_id"] == customer_id[0]][
                "insurance"
            ].values[
                0
            ]  # does the customer have insurance?
            experiment_id = self.Customers[
                self.Customers["customer_id"] == customer_id[0]
            ]["experiment_id"].values[
                0
            ]  # does the customer have insurance?

            event_list = (
                self.billing_choose_dates()
            )  # generate dates associated with this invoice
            cpt_code = random.sample(self.CPTCodes, 1)[0]
            date_of_service = str(event_list.values[0][0])
            created_on = str(event_list.values[1][0])
            date_of_eob = str(event_list.values[2][0])
            date_of_provider_adjustment = str(event_list.values[3][0])
            date_of_patient_payment = str(event_list.values[4][0])
            # generate a new invoice
            (invoice_id, charge_amount) = self.generate_new_invoice(
                created_on, date_of_service, customer_id, cpt_code
            )
            # generate subsequent EOB (i.e. copay, EOB adjustment, EOB payment)
            remaining_amount = self.generate_eob(
                date_of_service,
                date_of_eob,
                insured,
                invoice_id,
                cpt_code,
                charge_amount,
            )
            # generate provider adjustments
            remaining_amount = self.generate_provider_adjustment(
                date_of_provider_adjustment, invoice_id, cpt_code, remaining_amount
            )
            # generate a possible payment from the patient
            remaining_amount = self.generate_patient_payment(
                date_of_patient_payment,
                invoice_id,
                cpt_code,
                remaining_amount,
                experiment_id,
            )
            # record the remaining amounts in a separate table.
            self.record_remaining_amount(
                date_of_patient_payment, invoice_id, cpt_code, remaining_amount
            )
            return True
        else:
            print("Error generating new invoice- customerIds aren't consecutive")

    def generate_new_invoice(self, created_on, date_of_service, customer_id, cpt_code):
        """"""
        invoice_id = self.invoices[-1]
        self.invoices.append(self.invoices[-1] + 1)
        charge_amount = (
            np.random.exponential(400) + 100
        )  # random generated bill - minimum bill of 100
        invoicelineitem = pd.DataFrame(
            {
                "invoice_id": [invoice_id],
                "customer_id": customer_id,
                "cpt_code": [cpt_code],
                "created_on": [created_on],
                "charge_amount": [charge_amount],
                "date_of_service": [date_of_service],
            }
        )
        self.InvoiceLineItems = self.InvoiceLineItems.append(invoicelineitem)
        return (invoice_id, charge_amount)

    def generate_eob(
        self, date_of_service, date_of_eob, insured, invoice_id, cpt_code, charge_amount
    ):
        """
        Generate random values for
        1. Copayment
        2. EOB adjustment
        3. EOB payment (after Copay and adjustment)
        """
        if insured == "insured":
            # first copayments
            copay_amount = np.random.choice(
                self.distributions["copay_amounts"],
                1,
                p=self.distributions["copay_distribution"],
            )[0]
            if copay_amount > 0:
                invoicelineitemeob = pd.DataFrame(
                    {
                        "invoice_id": [invoice_id],
                        "cpt_code": [cpt_code],
                        "created_on": [date_of_service],
                        "copay_amount": [copay_amount],
                        "adjustment_amount": [0],
                        "paid_amount": [0],
                    }
                )
                self.InvoiceLineItemsEob = self.InvoiceLineItemsEob.append(
                    invoicelineitemeob
                )
                remaining_charge = charge_amount - copay_amount
            else:
                remaining_charge = charge_amount
            # next eob discounts
            eob_discount_percent = np.random.choice(
                self.distributions["eob_discount_percentages"],
                1,
                p=self.distributions["eob_discount_distribution"],
            )[0]
            if eob_discount_percent > 0:
                insurance_adjustment = remaining_charge * eob_discount_percent / 100
                remaining_charge = remaining_charge - insurance_adjustment
                invoicelineitemeob = pd.DataFrame(
                    {
                        "invoice_id": [invoice_id],
                        "cpt_code": [cpt_code],
                        "created_on": [date_of_eob],
                        "copay_amount": [0],
                        "adjustment_amount": [insurance_adjustment],
                        "paid_amount": [0],
                    }
                )
                self.InvoiceLineItemsEob = self.InvoiceLineItemsEob.append(
                    invoicelineitemeob
                )
            # next handle eob payments where relevant
            eob_payment_percentage = np.random.choice(
                self.distributions["eob_payment_percentages"],
                1,
                p=self.distributions["eob_payment_distribution"],
            )[0]
            eob_payment_amount = remaining_charge * (eob_payment_percentage / 100.0)
            if eob_payment_amount > 0:
                invoicelineitemeob = pd.DataFrame(
                    {
                        "invoice_id": [invoice_id],
                        "cpt_code": [cpt_code],
                        "created_on": [date_of_eob],
                        "copay_amount": [0],
                        "adjustment_amount": [0],
                        "paid_amount": [eob_payment_amount],
                    }
                )
                self.InvoiceLineItemsEob = self.InvoiceLineItemsEob.append(
                    invoicelineitemeob
                )
                remaining_charge = remaining_charge - eob_payment_amount
        else:
            remaining_charge = charge_amount
        return remaining_charge

    def generate_provider_adjustment(
        self, date_of_provider_adjustment, invoice_id, cpt_code, remaining_amount
    ):
        provider_adjustment_percentage = np.random.choice(
            self.distributions["provider_adjustment_percentages"],
            1,
            p=self.distributions["provider_adjustment_distribution"],
        )[0]
        if provider_adjustment_percentage > 0:
            provider_adjustment = remaining_amount * (
                provider_adjustment_percentage / 100.0
            )
            invoiceprovideradjustment = pd.DataFrame(
                {
                    "invoice_id": [invoice_id],
                    "cpt_code": [cpt_code],
                    "created_on": [date_of_provider_adjustment],
                    "adjustment_amount": [provider_adjustment],
                }
            )
            remaining_amount = remaining_amount - provider_adjustment
            self.InvoiceProviderAdjustments = self.InvoiceProviderAdjustments.append(
                invoiceprovideradjustment
            )
        return remaining_amount

    def generate_patient_payment(
        self,
        date_of_patient_payment,
        invoice_id,
        cpt_code,
        remaining_amount,
        experiment_id,
    ):
        # collection rate should depend on the experiment arm
        if experiment_id == 1:
            payment_percentage = np.random.choice(
                self.distributions["payment_percentages_arm_1"],
                1,
                p=self.distributions["payment_distribution_arm_1"],
            )[0]
        elif experiment_id == 2:
            payment_percentage = np.random.choice(
                self.distributions["payment_percentages_arm_2"],
                1,
                p=self.distributions["payment_distribution_arm_2"],
            )[0]

        else:
            print("Not a correct experiment id value")

        payment_amount = remaining_amount * (payment_percentage / 100.0)
        payment = pd.DataFrame(
            {
                "invoice_id": [invoice_id],
                "cpt_code": [cpt_code],
                "created_on": [date_of_patient_payment],
                "paid_amount": [payment_amount],
            }
        )
        self.Payments = self.Payments.append(payment)
        remaining_amount = remaining_amount - payment_amount
        return remaining_amount

    def record_remaining_amount(
        self, date_of_patient_payment, invoice_id, cpt_code, remaining_amount
    ):
        data = {
            "invoice_id": [invoice_id],
            "cpt_code": [cpt_code],
            "created_on": [date_of_patient_payment],
            "remaining": [remaining_amount],
        }
        remain = pd.DataFrame(data)
        self.Remaining = self.Remaining.append(remain)
        return True

    def write_to_csv(self):
        self.Customers.round(2).to_csv("Customers.csv", index=False)
        self.InvoiceLineItems.round(2).to_csv("InvoiceLineItems.csv", index=False)
        self.InvoiceLineItemsEob.round(2).to_csv("InvoiceLineItemsEob.csv", index=False)
        self.InvoiceProviderAdjustments.round(2).to_csv(
            "InvoiceProviderAdjustments.csv", index=False
        )
        self.Payments.round(2).to_csv("Payments.csv", index=False)
        self.Remaining.round(2).to_csv("Remaining.csv", index=False)
        return True
